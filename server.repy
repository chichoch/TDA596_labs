# Lab 4 helper functions 
# This skeleton does not handle race conditions/locks

# ------------------------------------------------------------------------------   
# Start listening and handle incoming connections in board() function
# ------------------------------------------------------------------------------   
def start_board():
  ip = mycontext['ip']
  port = mycontext['port']
  print "Listening on IP " + str(ip) +" port " + str(port)
  try: 
    listencommhandle = waitforconn(ip,port,board)
  except Exception, e:
    print "Exception in start_board: %s, %s\n" %(type(e), e)
    raise
    #pass

# ------------------------------------------------------------------------------    
# Called when an incoming message is received. 
# ------------------------------------------------------------------------------    
def board(ip, port, sockobj, thiscommhandle, listencommhandle):
  try:
    msgheader = sockobj.recv(1024) # Receive message
    
    # React depending on message type: HTTP GET or POST, or some other type of communication.
    if msgheader.startswith( 'GET' ):
      print "Received GET"
      handle_request_get(msgheader, sockobj, thiscommhandle)
    # TODO Maybe "fulkod"? 4 cases, but 2 of them do the same thing.  [FIXED WITH 'OR', OK?]
    elif msgheader.startswith( 'POST /Add' ):
      handle_request_add(msgheader, sockobj, thiscommhandle)
    elif msgheader.startswith( 'POST /Change' ) or msgheader.startswith( 'SENTDEL'):
      handle_request_change(msgheader, sockobj, thiscommhandle)
    elif msgheader.startswith( 'SENTADD' ):
      handle_request_add_from_vessel(msgheader, sockobj, thiscommhandle)
  except Exception, e:
    print "Exception in board: %s, %s\n" %(type(e), e)
    raise
# ------------------------------------------------------------------------------
# Handles initial GET request from browser, outputs HTML string and closes socket.
# ------------------------------------------------------------------------------
def handle_request_get(msgheader, sockobj, thiscommhandle):
  htmlresponse = generate_html_page("")
  sockobj.send(make_http_ok_response(htmlresponse))
  stopcomm(thiscommhandle)  

# ------------------------------------------------------------------------------
# Handles add request from another vessel, outputs HTML string and closes socket.
# ------------------------------------------------------------------------------
def handle_request_add_from_vessel(msgheader, sockobj, thiscommhandle):
  
  comment = str(msgheader[msgheader.find("comment=") + 8:msgheader.find("&src_ts=")])
  ref_ts = int(msgheader[msgheader.find("&src_ts=") + 8:msgheader.find("&src_ip=")])
  ref_ip = msgheader[msgheader.find("&src_ip=") + 8:msgheader.find("&src_port=")]
  ref_port = int(msgheader[msgheader.find("&src_port=") + 10:msgheader.find("&action=")])

  mycontext['ts'] = max(mycontext['ts'], ref_ts)

  commentDeleted = False

  #We don't add the comment if we have already recieved a delete-post for it
  for post in mycontext['unusedDelete']:
    if post[post.find("&src_ts=") + 8: post.find("&src_ip")] == str(ref_ts) and \
      post[post.find("&src_ip=") + 8: post.find("&src_port")] == ref_ip and \
      post[post.find("&src_port=") + 10: post.find("&action")] == str(ref_port):
      mycontext['unusedDelete'].remove(post)
      commentDeleted = True


  if not commentDeleted:
    # Add to local store
    entry = "comment=%s&src_ts=%u&src_ip=%s&src_port=%u&action=%s" % \
      (comment, ref_ts, ref_ip, ref_port, 'Add')
    mycontext['entrieslist'].append(entry)
  
  # Send the page
  handle_request_get(msgheader, sockobj, thiscommhandle)

# ------------------------------------------------------------------------------
# Handles POST \Add request from browser
# ------------------------------------------------------------------------------
def handle_request_add(msgheader, sockobj, thiscommhandle):
  print "Received Add"
  
  isFromVessel = msgheader.startswith( 'SENT' )
  print isFromVessel

  #increment logical clock
  mycontext['ts'] = mycontext['ts'] + 1
  
  #check if valid request (contains comment)
  comment=msgheader.split('comment=')[1]
  
  # Mark the entry as Add, and store attributes
  # We use the HTML query format to store the entries locally
  # example:
  # comment=aa&src_ts=2&src_ip=127.0.0.1&src_port=63101&action=Add
  entry = "comment=%s&src_ts=%u&src_ip=%s&src_port=%u&action=%s" % \
      (comment, mycontext['ts'], mycontext['ip'], mycontext['port'], 'Add')
  
  # Add to local store
  mycontext['entrieslist'].append(entry)
  
  # Send the page
  handle_request_get(msgheader, sockobj, thiscommhandle)

# Check if message is sent from another Vessel
# TODO Duplicated code... (See handle_request_change)
  if not isFromVessel:
    send_to_vessels("SENTADD" + entry)  
  
# ------------------------------------------------------------------------------
# Handles POST /Change request from browser
# ------------------------------------------------------------------------------
def handle_request_change(msgheader, sockobj, thiscommhandle):
  print "Received POST /Change"
  #increment logical clock
  mycontext['ts'] = mycontext['ts'] + 1

  isFromVessel = msgheader.startswith( 'SENT' )

  #extract the query from the HTTP request  
  if isFromVessel:
    # Remove SENTADD/SENTDEL from msgheader.
    query = extract_http_request_contents(msgheader[7:])
  else:
    query = extract_http_request_contents(msgheader)

  # extract the query parameters
  parameters = extract_parameters_from_query(query)
  print parameters
  comment = parameters['comment']
  action = parameters['action']
  ref_ts = int(parameters['ts'])
  ref_ip = parameters['ip']
  ref_port = int(parameters['port'])
  
  print "QUERY:", query, comment, action, ref_ts, ref_ip, ref_port

  
  foundAdd = False


  if action == "Delete":
    for entry in mycontext['entrieslist']:
      print entry[entry.find("&src_ts=") + 8: entry.find("&src_ip")] , str(ref_ts), \
        entry[entry.find("&src_ip=") + 8: entry.find("&src_port")],ref_ip, \
        entry[entry.find("&src_port=") + 10: entry.find("&action")],str(ref_port)
      #If ts, ip and port match then remove the comment
      if entry[entry.find("&src_ts=") + 8: entry.find("&src_ip")] == str(ref_ts) and \
        entry[entry.find("&src_ip=") + 8: entry.find("&src_port")] == ref_ip and \
        entry[entry.find("&src_port=") + 10: entry.find("&action")] == str(ref_port):
        mycontext['entrieslist'].remove(entry)
        print "REMOVED: " + entry
        foundAdd = True
    

  # Save the src ip/port and timestamp of the query
  e = "%s&src_ts=%u&src_ip=%s&src_port=%u" % (query, mycontext['ts'], mycontext['ip'], mycontext['port'])

  #If comment not found, store delete for future use
  if foundAdd == False and action == "Delete":
    mycontext['unusedDelete'].append(e)
  
  # Add query to local store
  mycontext['entrieslist'].append(e)
  
  #Send the page
  handle_request_get(msgheader, sockobj, thiscommhandle)

  # Check if message is sent from another Vessel
  if not isFromVessel:
    if action == "Delete":
      send_to_vessels("SENTDEL" + msgheader)

# ------------------------------------------------------------------------------
# Sends a message to all vessels (except this)
# ------------------------------------------------------------------------------
def send_to_vessels(entry):
  if mycontext['connection'] == "remote":
    for vessel in mycontext['vessels']:
      if (vessel != getmyip()):
        send_message(vessel, mycontext['port'], entry)
  else:
    for portnr in mycontext['localports']:
      if(int(portnr) != mycontext['port']):
        send_message('127.0.0.1', int(portnr), entry)

# ------------------------------------------------------------------------------
# Sends a message to specific ip:port
# ------------------------------------------------------------------------------
def send_message(ip, port, entry):
  try:
    socket = openconn(ip, port)
    socket.send(entry)
    socket.close()
  except Exception, e:
    print '-------SOCKET ERROR------\n' + str(e)
  
# ------------------------------------------------------------------------------
# Wrap into HTTP headers
# ------------------------------------------------------------------------------
def make_http_ok_response(htmlresponse):
    return "HTTP/1.1 200 OK\r\nContent-type: text/html\r\n" + \
    "Content-length: %i\r\n\r\n%s" % (len(htmlresponse), htmlresponse)

# ------------------------------------------------------------------------------
# Utility function to extract the contents (payload) from HTTP request
# ------------------------------------------------------------------------------
def extract_http_request_contents(header):
  # find content length
  conent_length = header.split('Content-Length: ')[1]
  conent_length = int(conent_length.split('\r\n')[0])
  
  # extract the http response body and discard the header
  contetns = header[-conent_length:]
  return contetns

# ------------------------------------------------------------------------------
# Utility function to extract query parameter from HTML query
# ------------------------------------------------------------------------------
def extract_parameters_from_query(msg):
  # extract the query parameters as a dictionary: {name:value}
  # example input format: comment=aa&ts=2&ip=127.0.0.1&port=63101&action=Delete
  parameters={}
  arr = msg.split('&')
  for a in arr:
    pp = a.split('=')
    if len(pp)>1:
      parameters[pp[0]] = pp[1]
  return parameters

# ------------------------------------------------------------------------------
# Utility function to wrap an entry with HTML form markup
# ------------------------------------------------------------------------------
def entry_to_html(entry):
  if len(entry) > 0:
    # extract the query parameters
    parameters = extract_parameters_from_query(entry)
    comment = parameters['comment']
    action = parameters['action']
    src_ts = int(parameters['src_ts'])
    src_ip = parameters['src_ip']
    src_port = int(parameters['src_port'])
    
    if action == 'Add':
      return '''<form class="entry" method="post" action="Change" >
                  <input type="text" name="comment" value="%s" size="50"/>
                  <input type="hidden" name="ts" value="%u" />
                  <input type="hidden" name="ip" value="%s" />
                  <input type="hidden" name="port" value="%u" />
                  <input type="submit" name="action" value="Modify" />
                  <input type="submit" name="action" value="Delete" />
                </form>''' %(comment, src_ts, src_ip, src_port)
  return "" 
       
# ------------------------------------------------------------------------------
# Outputs the blackboard html 
# Optional parameter: status.
# ------------------------------------------------------------------------------   
def generate_html_page(status=""):
  #Initialize blackboard content
  
  # dynamic title showing Ip address, port and up time.
  board_title = '<div id="boardtitle_placeholder" class="boardtitle">Board contents at host: %s:%u, up time: %u sec.</div>'\
           %(mycontext['ip'], mycontext['port'], int(getruntime()))  
  # An optional status message
  status_message = "<div class='status'>%s</div>" % (status)
  
  # convert entries to html
  entries = [entry_to_html(e) for e in mycontext['entrieslist']]
  entries = "".join(entries)
  
  # merging the contents of the board with the title
  # and wrapping all with <div id="boardcontents_placeholder”>...</div>
  content = [mycontext['headerhtml'], '<div id="boardcontents_placeholder">', \
     board_title, status_message, entries, '</div>', mycontext['footerhtml']]   
  
  #Concatenate strings into huge string representing the final html
  content = "".join(content)
  del entries
  return content
  
# ------------------------------------------------------------------------------    
# Main entry point of the program. Initalizes global variables in mycontext
# and calls start_board() which opens the socket for incoming connections.
# ------------------------------------------------------------------------------
if callfunc == 'initialize':
  # Running remotely (assuming that we pass one input argument only when we run remotely):
  # whenever this vessel gets a connection on its IPaddress:Clearinghouseport it'll call function board
  if len(callargs) == 1:
    port = int(callargs[0])
    mycontext['vessels'] = open('ipaddresses.txt','r').read().split()
    ip = getmyip()
    mycontext['connection'] = "remote"

  # To run locally: use the loopback ip address (127.0.0.1) and a port in the range 63100 .. 63110
  # If you start multiple local instances using different ports, you can debug and test your code locally
  # example:
  # python ../demokit/repy.py ../demokit/restrictions.default skeleton2015advanced.repy 127.0.0.1 63100
  elif len(callargs) == 2:
    port = int(callargs[1])
    ip = callargs[0]
    mycontext['localports'] = open('localports.txt', 'r').read().split()
    mycontext['connection'] = "local"

  # Fail if we don't have 1 or 2 arguments  
  else:
    raise Exception("Specify a port only for auto detection of IP, or specify IP and port")

  #GLOBAL Variables go to mycontext
  
  #logical clock\timestamp
  mycontext['ts'] = 0 
  
  #Initialize Port and IP
  mycontext['port'] = port
  mycontext['ip'] = ip
  
  #read header and footer html files
  mycontext['headerhtml'] = file("header.html").read()
  mycontext['footerhtml'] = file("footer.html").read()

  #Initialize entrieslist to hold future board entries
  mycontext['entrieslist'] = []

  #Initialized list of delete messages
  mycontext['unusedDelete'] = []
  
  start_board() 
