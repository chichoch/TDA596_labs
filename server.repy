# Inserts a new message into the stored html file  
def insert_message(message):
  if message != '':  
    index = mycontext['index']
    mycontext['index'] = index[:index.find('<p>')+3] + '<p>' + message + '</p>' + index[index.find('<p>')+3:]

# Sends a message to all vessels (except this)
def send_to_vessels(message):
  for vessel in mycontext['vessels']:
      if (vessel != getmyip()):
        send_message(vessel, mycontext['port'], message)
        
# Sends a message to all ports (except this)
def send_to_local_ports(message):
  for portnr in mycontext['localports']:
    if(int(portnr) != mycontext['port']):
      send_message('127.0.0.1', int(portnr), message)

# Sends a message to specific ip:port
def send_message(ip, port, message):
  try:
    socket = openconn(ip, int(port))
    socket.send(message)
    socket.close()
  except Exception, e:
    print '-------SOCKET ERROR------\n' + str(e)

def local_get_next_vessel():
  next_vessel_pos = (mycontext['localports'].index(str(mycontext['port'])) + 1) % (len(mycontext['localports']))
  mycontext['next_vessel_ip'] = mycontext['ip']
  mycontext['next_vessel_port'] = mycontext['localports'][next_vessel_pos]
  
  #message = "ELECTION:i" + mycontext['processID'] + 'l' + mycontext['processID'] + '/' + mycontext['random']
  #initiator = message[message.find('i')+1:message.find('l')-1]
  #print(initiator)

def remote_get_next_vessel():
  next_vessel_pos = (mycontext['vessels'].index(mycontext['ip']) + 1) % (len(mycontext['vessels']))
  mycontext['next_vessel_ip'] = mycontext['vessels'][next_vessel_pos]
  mycontext['next_vessel_port'] = mycontext['port']

def start_election():
  #ELECTION:i127.0.0.1:12345l127.0.0.1:12345/0.1234353467
  
  processId = mycontext['ip'] + ':' + str(mycontext['port'])
  electionMessage = "ELECTION:i" + processId + 'l' + processId + '/' + str(mycontext['random'])

  send_message(mycontext['next_vessel_ip'], mycontext['next_vessel_port'], electionMessage)

def send_ok():
  # Get the stored html file
  htmlresponse = mycontext['index']
  # Send the html file to the socket
  sockobj.send("HTTP/1.1 200 OK\r\nContent-type: text/html\r\n" + \
  "Content-length: %i\r\n\r\n%s" % (len(htmlresponse), htmlresponse))
  stopcomm(thiscommhandle)

def board(ip, port, sockobj, thiscommhandle, listencommhandle):
  lock = getlock()
  lock.acquire() 
  mycontext['boardcounter'] += 1
  print mycontext['boardcounter']
  try:
    msgheader = sockobj.recv(1024) # Receive message, 
  except Exception, e:
    print '------RECIEVE ERROR-------\n' + str(e)
    msgheader = ''

  # React depending on message type: HTTP GET or POST, or some other type of communication.
  if msgheader.startswith( 'GET' ):
    send_ok()   
  
  elif msgheader.startswith( 'POST' ):
    leader = mycontext['leader']
    if leader != mycontext['processID']:
      #Send the message to leader.
      send_message(leader[:leader.find(':')], leader[leader.find(':')+1:], msgheader)
      sleep(0.5)
      send_ok()

    else:
      #Get the message from the post
      message = msgheader[msgheader.find("comment=")+8:]
      
      #Insert the message to the html file
      insert_message(message)
      
      send_ok()

      #Send message to vessels or ports, depending on which connection is used.
      if mycontext['connection'] == 'remote':
        send_to_vessels("OK" + message) 
      else:
        send_to_local_ports("OK" + message)

  elif msgheader.startswith('OK'):
    message = msgheader[msgheader.find('OK') + 2:]
    print msgheader
    #Insert the message to the html file
    insert_message(message)
    
    send_ok()

  #On-going election
  elif msgheader.startswith('ELECTION'):
    initiator = msgheader[msgheader.find('i')+1:msgheader.find('l')]
    #If we are leader
    if initiator == mycontext['processID']:
      #Get the election winner from the message
      leader = msgheader[msgheader.find('l')+1:msgheader.find('/')]
      #Start letting all nodes know about the new leader
      leaderMessage = "LEADER:i" + initiator + 'l' + leader
      mycontext['leader'] = leader
      send_message(mycontext['next_vessel_ip'], mycontext['next_vessel_port'], leaderMessage)
    else:
      #Compare our random to leader
      leaderRand = msgheader[msgheader.find('/')+1:]
      if mycontext['random'] > float(leaderRand):
        #Continue election with this as leader
        newMessage = msgheader[:msgheader.find('l')+1] + mycontext['processID'] + '/' + str(mycontext['random'])
        print "NEW LEADER: " + newMessage
        send_message(mycontext['next_vessel_ip'], mycontext['next_vessel_port'], newMessage)
      else:
        #Continue election with previous leader
        send_message(mycontext['next_vessel_ip'], mycontext['next_vessel_port'], msgheader)

  #A leader has been selected
  elif msgheader.startswith('LEADER'):
    initiator = msgheader[msgheader.find('i')+1:msgheader.find('l')]
    if initiator != mycontext['processID']:
      mycontext['leader'] = msgheader[msgheader.find('l') + 1:]
      send_message(mycontext['next_vessel_ip'], mycontext['next_vessel_port'], msgheader)
    #TODO REMOVE
    print "------- LEADER: " +  mycontext['leader'] + "This vessel: " + mycontext['processID']

  else:
    # Shouldn't happen.
    raise Exception("Can't recognize messageheader")

  lock.release()
  

# ------------------ INITIALIZE --------------------------------
if callfunc == 'initialize':
  if len(callargs) != 2:
    raise Exception("Need two call arguments")

  #TODO REMOVE
  mycontext['boardcounter'] = 0
  # Read and store the html file
  mycontext['index'] = open('index.html', 'r').read()
  # Store which connection type used. (remote or local) 
  mycontext['connection'] = callargs[0]
  # Store port used.
  port = int(callargs[1])
  mycontext['port'] = int(callargs[1])

  mycontext['random'] = randomfloat()
  #TODO Remove
  print mycontext['random']


  #Generate random number
  #mycontext['random'] = randomfloat() * 

  
  # Running remotely: 
  if callargs[0] == 'remote':
    # Read and store ip-addresses of other vessels
    mycontext['vessels'] = open('ipaddresses.txt','r').read().split()  
    ip = getmyip()
    mycontext['ip'] = getmyip()

    #Store process-id
    mycontext['processID'] = mycontext['ip'] + ':' + str(mycontext['port'])
    remote_get_next_vessel()

  # Running locally.
  elif callargs[0] == 'local':
    # Read and store the ports for running instances on localhost.
    mycontext['localports'] = open('localports.txt', 'r').read().split()
    ip = '127.0.0.1'
    mycontext['ip'] = '127.0.0.1'
    
    #Store process-id
    mycontext['processID'] = mycontext['ip'] + ':' + str(mycontext['port'])
    
    local_get_next_vessel()
  
  else:
    raise Exception("First argument needs to be 'remote' or 'local'")

  #Start selection, but first wait 1 sec to let all intances be initiated.
  settimer(1, start_election, [])

  # Whenever this vessel gets a connection on its IPaddress:port it'll call function board
  listencommhandle = waitforconn(ip,port,board)