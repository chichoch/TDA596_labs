# Represents a blackboard-message.
class Message:
  def __init__(self, content, seqNr, sender, receiver):
    self.content = content
    self.seqNr = seqNr
    self.sender = sender
    self.receiver = receiver

  def toString(self):
    return "MESSAGE:" + self.content + "Seq:" + str(self.seqNr) + "Sender:" +\
       self.sender + "Receiver:" +self.receiver

  def setReceiver(self, receiver):
    self.receiver = receiver

  def setSender(self, sender):
    self.sender = sender

def resend_messages():
  while True:
    sleep(5)
    mycontext['noACKlist_lock'].acquire()
    for message in mycontext['noACKlist']:
      print "------NoACK List--------" , mycontext['noACKlist'], "-------------------"
      if mycontext['isJoined']:  
        print "RESENDING: " + message.toString()
        ip = message.receiver[:message.receiver.find(':')]
        port = message.receiver[message.receiver.find(':') + 1:]
        send_message(ip, int(port), message.toString())
    mycontext['noACKlist_lock'].release()

# Sort the message list first by sender and then by seq nr to assure same order on all vessels.
def sort_messages():
  items = mycontext['local_message_list']

  #Insertion-sort by sender:
  for i in range(1, len(items)):
    j = i
    while j > 0 and items[j].sender < items[j-1].sender:
      items[j], items[j-1] = items[j-1], items[j]
      j -= 1
  #Insertion-sort by seqNr:
  for i in range(1, len(items)):
    j = i
    while j > 0 and items[j].seqNr < items[j-1].seqNr:
      items[j], items[j-1] = items[j-1], items[j]
      j -= 1

# Inserts a new message into the message list, sorts the list and created the html.  
def insert_message(message):
  # Locks are used to assure mutual exclusion of the list. 
  mycontext['list_lock'].acquire()
  # Adds the message to the list.
  mycontext['local_message_list'].append(message)
  # Sort the list first on seqNr and then IP-address.
  sort_messages()

  # Update the index.html-file
  mycontext['index'] = mycontext['empty_html']
  for message in mycontext['local_message_list']:
    mycontext['index'] = mycontext['index'][:mycontext['index'].find('<p>')+3] + '<p>' + \
          message.content + '</p>' + mycontext['index'][mycontext['index'].find('<p>')+3:]
  mycontext['list_lock'].release()

# Sends a message to all vessels (except this)
def send_to_vessels(message):
  mycontext['noACKlist_lock'].acquire()
  for vessel in mycontext['vessels']:
      print vessel + " == " + getmyip() + ' EQUALS ' + str(vessel != getmyip())
      if (vessel != getmyip()):
        message.setReceiver(vessel + ":" + str(mycontext['port']))
      
        if message not in mycontext['noACKlist'] and mycontext['iamspecial']:  
          mycontext['noACKlist'].append(message)
          send_message(vessel, mycontext['port'], message.toString())
        elif not mycontext['iamspecial'] and mycontext['isJoined']:
          mycontext['noACKlist'].append(message)
          send_message(vessel, mycontext['port'], message.toString())
        elif not mycontext['iamspecial'] and not mycontext['isJoined']:
          mycontext['noACKlist'].append(message)
  mycontext['noACKlist_lock'].release()
  #resend_messages()

# Sends a message to all ports (except this)
def send_to_local_ports(message):
  counter = 0
  mycontext['noACKlist_lock'].acquire()
  for portnr in mycontext['localports']:
    print "PORTNUMBERS IN LOCALPORTS: " + str(portnr)
    if(int(portnr) != int(mycontext['port'])):
      message.setReceiver('127.0.0.1' + ':' + portnr)
      
      mycontext['noACKlist'].append(message)
      send_message('127.0.0.1', int(portnr), message.toString())

  if not mycontext['isJoined']:
    if mycontext['group'] == 'A':
      for p in mycontext['groupA']:
        if (int(p) != int(mycontext['port'])):
          message.setReceiver('127.0.0.1' + ':' + p)
          mycontext['noACKlist'].append(message)
    elif mycontext['group'] == 'B':
      for p in mycontext['groupB']:
        if (int(p) != int(mycontext['port'])):
          message.setReceiver('127.0.0.1' + ':' + p)
          mycontext['noACKlist'].append(message)
    else:
      tempList = mycontext['groupA']
      tempList.extend(mycontext['groupB'])
      for p in tempList:
        print p
        if (int(p) != int(mycontext['port'])):
          message.setReceiver('127.0.0.1' + ':' + p)
          mycontext['noACKlist'].append(message)
      #if mycontext['isJoined']:
      #  mycontext['noACKlist'].append(message)
      #  send_message('127.0.0.1', int(portnr), message.toString())
      #  counter = counter +1
      #  print "SENT MESSAGE. Counter: " + str(counter)
      #else:
      #  mycontext['noACKlist'].append(message)
      #  if mycontext['group'] == 'A':




      #if mycontext['iamspecial'] and mycontext['isJoined']:  
      #if message not in mycontext['noACKlist'] and mycontext['iamspecial']:  
      #  mycontext['noACKlist'].append(message)
      #  send_message('127.0.0.1', int(portnr), message.toString())
      #elif not mycontext['iamspecial'] and mycontext['isJoined']:
      #  mycontext['noACKlist'].append(message)
      #  send_message('127.0.0.1', int(portnr), message.toString())
      #elif not mycontext['iamspecial'] and not mycontext['isJoined']:
      #  mycontext['noACKlist'].append(message)
      
  mycontext['noACKlist_lock'].release()
  #resend_messages()
      
      
      #TODO Detta gör att det inte skickas några meddelanden från 2:an?
      #if mycontext['isJoined']:
      #  send_message('127.0.0.1', int(portnr), message.toString())

# Sends a message to specific ip:port
def send_message(ip, port, message):
  try:
    socket = openconn(ip, port)
    socket.send(message)
    socket.close()
  except Exception, e:
    print '-------SOCKET ERROR------\n' + str(e)

def message_from_string(string):
  content = string[string.find("MESSAGE:") + 8 : string.find("Seq:")]
  seqNr = int(string[string.find("Seq:") + 4 : string.find("Sender:")])
  sender = string[string.find("Sender:") + 7:string.find("Receiver:")]
  receiver = string[string.find("Receiver:") + 9:]
  return Message(content, seqNr, sender, receiver)

def board(ip, port, sockobj, thiscommhandle, listencommhandle):
  try:
    msgheader = sockobj.recv(1024) # Receive message, 
  except Exception, e:
    print '------RECIEVE ERROR-------\n' + str(e)
    msgheader = ''

  # React depending on message type: HTTP GET or POST, or some other type of communication.
  if msgheader.startswith( 'GET' ):
    # Get the stored html file
    htmlresponse = mycontext['index']
    # Send the html file to the socket
    sockobj.send("HTTP/1.1 200 OK\r\nContent-type: text/html\r\n" + \
    "Content-length: %i\r\n\r\n%s" % (len(htmlresponse), htmlresponse))
    stopcomm(thiscommhandle)   
 
 # ======================== POST ============================
  elif msgheader.startswith( 'POST' ):
    #Get the comment from the post
    comment = msgheader[msgheader.find("comment=")+8:]
    
    #It is important to have mutex access to the clock
    mycontext['clock_lock'].acquire()
    #We have made a new comment, meaning we have to increase the clock.
    mycontext['logical_clock'] += 1
    #Create a message-object.
    message = Message(comment, mycontext['logical_clock'], mycontext['ip'] + ":" + str(mycontext['port']), "")
    mycontext['clock_lock'].release()

    #Insert the message to the html file
    insert_message(message)
    
    #Get the stored html file
    response = mycontext['index']
    
    #Send the complete file to the socket.
    sockobj.send("HTTP/1.1 200 OK\r\nContent-type: text/html\r\n" + \
    "Content-length: %i\r\n\r\n%s" % (len(response), response))
    stopcomm(thiscommhandle)

    #Send message to vessels or ports, depending on which connection is used.
    if mycontext['connection'] == 'remote':
      send_to_vessels(message) 
    else:
      send_to_local_ports(message)

# ====================== BREAK =====================
  elif msgheader.startswith( 'BREAK' ):
    mycontext['isJoined'] = False
    if mycontext['connection'] == "local":
      for v in mycontext['groupB']:
        if int(v) != mycontext['port']:
          send_message(mycontext['ip'], int(v), "FORGETME&" + str(mycontext['port']))
        mycontext['localports'].remove(v)
      print "BREAK: ", mycontext['localports']
    # Remote  
    else:
      for v in mycontext['groupB']:
        if v != mycontext['ip']:
          send_message(v, mycontext['port'], "FORGETME&" + mycontext['ip'])
        mycontext['vessels'].remove(v)
      print "BREAK: ", mycontext['vessels']

# =============== JOIN ======================  
  elif msgheader.startswith( 'JOIN' ):
    mycontext['isJoined'] = True
    if mycontext['connection'] == "remote":
      for v in mycontext['groupB']:
        if v != mycontext['ip']:
          send_message(v, mycontext['port'], "REMEMBERME&" + mycontext['ip'])   
      mycontext['vessels'].extend(mycontext['groupB'])
      print "JOIN: ", mycontext['vessels']
    # Local  
    else:
      for v in mycontext['groupB']:
        if int(v) != mycontext['port']:
          send_message(mycontext['ip'], int(v), "REMEMBERME&" + str(mycontext['port']))
      mycontext['localports'].extend(mycontext['groupB'])
      print "JOIN: ", mycontext['localports']

# =============== FORGETME ==================    
  elif msgheader.startswith( 'FORGETME' ):
    print "FORGET ME"
    mycontext['isJoined'] = False
    if mycontext['connection'] == "remote":
      mycontext['vessels'].remove(msgheader[msgheader.find("&") +1:])
      print "REMOVED: " + msgheader[msgheader.find("&") +1:]
      print "Vessels: ", mycontext['vessels']
    
    # Local
    else:
      mycontext['localports'].remove(msgheader[msgheader.find("&") +1:])
      print "REMOVED: " + msgheader[msgheader.find("&") +1:]
      print "Ports: ", mycontext['localports']
# ==================== REMEMBER ME ================
  elif msgheader.startswith( 'REMEMBERME'):
    print "REMEMBER ME"
    mycontext['isJoined'] = True
    if mycontext['connection'] == "remote":
      mycontext['vessels'].append(msgheader[msgheader.find("&") +1:])
      print "ADDED: " + msgheader[msgheader.find("&") +1:]
      print "Vessels: ", mycontext['vessels']

    #Local
    else:
      mycontext['localports'].append(msgheader[msgheader.find("&") +1:])
      print "ADDED: " + msgheader[msgheader.find("&") +1:]
      print "Ports: ", mycontext['localports']


# ================== ACK ==========================
  # We recieved an ACK from some message.
  elif msgheader.startswith( 'ACK' ):
    message = message_from_string(msgheader)
    mycontext['noACKlist_lock'].acquire()
    print "Received ACK FROM " + message.receiver
    print "--------------"
    for m in mycontext['noACKlist']:
      print m.toString()

    print "---------------"
    for mess in mycontext['noACKlist']:
      if mess.sender == message.sender and mess.receiver == message.receiver and \
              mess.content == message.content and mess.seqNr == message.seqNr:
        mycontext['noACKlist'].remove(mess)

    #Delete the last object if found!:
    try:
      if mess.sender == message.sender and mess.receiver == message.receiver and \
              mess.content == message.content and mess.seqNr == message.seqNr:
        mycontext['noACKlist'].remove(mess)
    except Exception, e:
      print "not found"
        #print "MESSAGE REMOVED: " + mess.toString()
      #else:
        #print "!!!!!!!!!!!!!! MESSAGE NOT REMOVED: " + mess.toString() + "\n MESSAGE2 : ", message.toString()
    mycontext['noACKlist_lock'].release()
 

# ========================= MESSAGE ===================
  else:
    # Recieved a message.
    # Ignore empty messages. (Can be caused by socket-errors etc.)
    if (msgheader != ''):
      # Create Message-object from String:
      message = message_from_string(msgheader)
      print message.toString()

      #SEND ACK
      if mycontext['connection'] == 'remote':
        ip = message.sender[:message.sender.find(':')]
        port = mycontext['port']
        send_message(ip, int(port), "ACK" + message.toString())
      else:
        # Local:
        ip = '127.0.0.1'
        port = message.sender[message.sender.find(':') + 1:]
        send_message(ip, int(port), "ACK" + message.toString())

      #It is important to have mutex access to the clock
      mycontext['clock_lock'].acquire()
      # Set logical_clock to max(recv.seqNr,logical_clock)
      mycontext['logical_clock'] = max(message.seqNr, mycontext['logical_clock'])
      mycontext['clock_lock'].release()

      # Insert the message in the list, sort it and update html-file.
      insert_message(message)

      # If we are the "special node" that connects the to subnets:
      if mycontext['iamspecial']:
        ip = ""
        port = 0
        if mycontext['connection'] == 'remote':
          senderIP = message.sender[:message.sender.find(':')]
          port = mycontext['port']
          mycontext['noACKlist_lock'].acquire()
          if senderIP in mycontext['groupA'] and senderIP != getmyip():
            for v in mycontext['groupB']:
              if v != mycontext['ip']:
                ip = v
                message.setReceiver(v + ':' + str(port))
                message.setSender(mycontext['ip'] + ':' + str(port))
                if message not in mycontext['noACKlist']:  
                  mycontext['noACKlist'].append(message)
                if mycontext['isJoined']:
                  send_message(ip,port,message.toString())
                #send_message(msgheader)
          elif senderIP in mycontext['groupB'] and senderIP != getmyip():
            for v in mycontext['groupA']:
              if v != mycontext['ip']:
                ip = v
                message.setReceiver(v + ':' + str(port))
                message.setSender(mycontext['ip'] + ':' + str(port))
                if message not in mycontext['noACKlist']:  
                  mycontext['noACKlist'].append(message)
                if mycontext['isJoined']:
                  send_message(ip,port,message.toString())  
          mycontext['noACKlist_lock'].release()

        elif mycontext['connection'] == 'local':
          senderPort = message.sender[message.sender.find(':') + 1:]
          ip = '127.0.0.1'
          #print senderPort, "GROUPA: " + str(mycontext['groupA']), "GROUPB: " + str(mycontext['groupB']),\
          #      "In group A: " + str(senderPort in mycontext['groupA']), "In group B: " + str(senderPort in mycontext['groupB'])
          mycontext['noACKlist_lock'].acquire()
          if senderPort in mycontext['groupA'] and senderPort != mycontext['port']:
            for v in mycontext['groupB']:
              if v != str(mycontext['port']):
                port = int(v)
                message.setReceiver('127.0.0.1' + ':' + str(v))
                message.setSender('127.0.0.1' + ':' + str(mycontext['port']))
                #if message not in mycontext['noACKlist']:
                mycontext['noACKlist'].append(message)
                if mycontext['isJoined']:
                  send_message(ip,port,message.toString())
                #send_message('127.0.0.1', int(v), message.toString())
          elif senderPort in mycontext['groupB'] and senderPort != mycontext['port']:
            for v in mycontext['groupA']:
              if v != str(mycontext['port']):
                port = int(v)
                message.setReceiver('127.0.0.1' + ':' + str(v))
                message.setSender('127.0.0.1' + ':' + str(mycontext['port']))
                #if message not in mycontext['noACKlist']:
                mycontext['noACKlist'].append(message)
                if mycontext['isJoined']:
                  send_message(ip,port,message.toString())
                #send_message('127.0.0.1', int(v), message.toString())
          mycontext['noACKlist_lock'].release()
        #if mycontext['isJoined']:
        #  send_message(ip,port,message.toString())
    #resend_messages()

  
if callfunc == 'initialize':
  if len(callargs) != 3:
    raise Exception("Need three call arguments")

  # Read and store the html file
  mycontext['index'] = open('index.html', 'r').read()
  mycontext['empty_html'] = mycontext['index']
  # Store which connection type used. (remote or local) 
  mycontext['connection'] = callargs[0]
  # Store port used.
  port = int(callargs[1])
  mycontext['port'] = int(callargs[1])
  mycontext['ip'] = '127.0.0.1'

  # Local logical clock
  mycontext['logical_clock'] = 0

  # Local list with messages
  mycontext['local_message_list'] = []

  mycontext['clock_lock'] = getlock()
  mycontext['list_lock'] = getlock()
  mycontext['noACKlist_lock'] = getlock()

  # Global variables for Task2part1:
  mycontext['localports'] = []
  mycontext['vessels'] = []
  mycontext['group'] = ''
  mycontext['groupB'] = []
  mycontext['groupA'] = []
  mycontext['isJoined'] = True

  #Global variables for Task2part2:
  mycontext['noACKlist'] = []

  if callargs[2] == 'AB':
    mycontext['iamspecial'] = True
  else:
    mycontext['iamspecial'] = False

  # Running remotely: 
  if callargs[0] == 'remote':
    # Read and store ip-addresses of other vessels
    ip = getmyip()
    mycontext['ip'] = ip
    if callargs[2] == "A":
      #You're in group A
      mycontext['group'] = 'A'
      mycontext['vessels'] = open('ipaddressesA.txt','r').read().split()  
    elif callargs[2] == "B":
      mycontext['group'] = 'B'    
      #You're in group B
      mycontext['vessels'] = open('ipaddressesB.txt','r').read().split()  
    elif callargs[2] == "AB":
      #You're in group A and B
      mycontext['group'] = 'AB'     
      mycontext['vessels'] = open('ipaddressesA.txt','r').read().split()
      mycontext['vessels'].extend(open('ipaddressesB.txt','r').read().split())
      mycontext['groupB'] = open('ipaddressesB.txt','r').read().split()
      mycontext['groupA'] = open('ipaddressesA.txt','r').read().split()


  # Running locally.
  elif callargs[0] == 'local':
    # Read and store the ports for running instances on localhost.
    ip = '127.0.0.1'
    if callargs[2] == "A":
      mycontext['group'] = 'A'
      #You're in group A
      mycontext['localports'] = open('localportsA.txt','r').read().split()  
    elif callargs[2] == "B":
      mycontext['group'] = 'B'
      #You're in group B
      mycontext['localports'] = open('localportsB.txt','r').read().split()  
    elif callargs[2] == "AB":
      mycontext['group'] = 'AB'
      #You're in group A and B
      mycontext['localports'] = open('localportsA.txt','r').read().split()
      mycontext['localports'].extend(open('localportsB.txt','r').read().split())
      mycontext['groupB'] = open('localportsB.txt','r').read().split()
      mycontext['groupA'] = open('localportsA.txt','r').read().split()

  else:
    raise Exception("First argument needs to be 'remote' or 'local'")
    
  settimer(5, resend_messages, [])
  # Whenever this vessel gets a connection on its IPaddress:port it'll call function board
  listencommhandle = waitforconn(ip,port,board)