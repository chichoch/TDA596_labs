class Message:
  def __init__(self, content, seqNr, sender):
    self.content = content
    self.seqNr = seqNr
    self.sender = sender

  def toString(self):
    return "MESSAGE:" + self.content + "Seq:" + str(self.seqNr) + "Sender:" + self.sender

def sort_messages():
  items = mycontext['local_message_list']

  #Insertion-sort by sender:
  for i in range(1, len(items)):
    j = i
    while j > 0 and items[j].sender < items[j-1].sender:
      items[j], items[j-1] = items[j-1], items[j]
      j -= 1
  #Insertion-sort by seqNr:
  for i in range(1, len(items)):
    j = i
    while j > 0 and items[j].seqNr < items[j-1].seqNr:
      items[j], items[j-1] = items[j-1], items[j]
      j -= 1

def board(ip, port, sockobj, thiscommhandle, listencommhandle):
  try:
    msgheader = sockobj.recv(1024) # Receive message, 
  except Exception, e:
    print '------RECIEVE ERROR-------\n' + str(e)
    msgheader = ''

  # React depending on message type: HTTP GET or POST, or some other type of communication.
  if msgheader.startswith( 'GET' ):
    # Get the stored html file
    htmlresponse = mycontext['index']
    # Send the html file to the socket
    sockobj.send("HTTP/1.1 200 OK\r\nContent-type: text/html\r\n" + \
    "Content-length: %i\r\n\r\n%s" % (len(htmlresponse), htmlresponse))
    stopcomm(thiscommhandle)   
  
  elif msgheader.startswith( 'POST' ):
    mycontext['message_counter'] += 1
    if(mycontext['message_counter'] == 1):
      mycontext['start_time'] = getruntime()
      print "STARTTIME: " + str(getruntime())

    if(mycontext['message_counter'] == 9):
      mycontext['end_time'] = getruntime()
     
    
    #Get the comment from the post
    comment = msgheader[msgheader.find("comment=")+8:]
    
    #It is important to have mutex access to the clock
    mycontext['clock_lock'].acquire()
    #We have made a new commment, meaning we have to increase the clock.
    mycontext['logical_clock'] += 1
    mycontext['clock_lock'].release()
    
    message = Message(comment, mycontext['logical_clock'], mycontext['ip'] + ":" + str(mycontext['port']))

    #Insert the message to the html file
    # TODO This need to create the html-file from the list instead.
    insert_message(message)
    
    #Get the stored html file
    response = mycontext['index']
    
    #Send the complete file to the socket.
    sockobj.send("HTTP/1.1 200 OK\r\nContent-type: text/html\r\n" + \
    "Content-length: %i\r\n\r\n%s" % (len(response), response))
    stopcomm(thiscommhandle)

    #Send message to vessels or ports, depending on which connection is used.
    if mycontext['connection'] == 'remote':
      send_to_vessels(message.toString()) 
    else:
      send_to_local_ports(message.toString())

 
  else:
    # Recieved a message.
    # Create Message-object from String:
    if (msgheader != ''):
      mycontext['message_counter'] += 1
      print "MESSAGE: " + str(mycontext['message_counter'])
      if(mycontext['message_counter'] == 1):
        mycontext['start_time'] = getruntime()
        print "STARTTIME: " + str(getruntime())


      if(mycontext['message_counter'] == 9):
        mycontext['end_time'] = getruntime()
        print "ENDTIME: " + str(mycontext['end_time'])
        print "\n Elapsed time: " + str(mycontext['end_time'] - mycontext['start_time'  ])
      

      message = message_from_string(msgheader)

      #It is important to have mutex access to the clock
      mycontext['clock_lock'].acquire()
      # Set logical_clock to max(recv.seqNr,logical_clock)
      mycontext['logical_clock'] = max(message.seqNr, mycontext['logical_clock'])
      mycontext['clock_lock'].release()

      # Put the message in the right place of "local_message_list"
      insert_message(message)
      # create html from the list.

    

  
if callfunc == 'initialize':
  if len(callargs) != 2:
    raise Exception("Need two call arguments")

  # Read and store the html file
  mycontext['index'] = open('index.html', 'r').read()
  mycontext['empty_html'] = mycontext['index']
  # Store which connection type used. (remote or local) 
  mycontext['connection'] = callargs[0]
  # Store port used.
  port = int(callargs[1])
  mycontext['port'] = int(callargs[1])
  mycontext['ip'] = '127.0.0.1'

  # Local logical clock
  mycontext['logical_clock'] = 0

  # Local list with messages
  mycontext['local_message_list'] = []

  mycontext['clock_lock'] = getlock()
  mycontext['insert_lock'] = getlock()

  mycontext['message_counter'] = 0

  # Running remotely: 
  if callargs[0] == 'remote':
    # Read and store ip-addresses of other vessels
    mycontext['vessels'] = open('ipaddresses.txt','r').read().split()  
    ip = getmyip()
    mycontext['ip'] = ip

  # Running locally.
  elif callargs[0] == 'local':
    # Read and store the ports for running instances on localhost.
    mycontext['localports'] = open('localports.txt', 'r').read().split()
    ip = '127.0.0.1'

  else:
    raise Exception("First argument needs to be 'remote' or 'local'")
    
  # Whenever this vessel gets a connection on its IPaddress:port it'll call function board
  listencommhandle = waitforconn(ip,port,board)

# Inserts a new message into the message list, sorts the list and created the html.  
def insert_message(message):

  mycontext['insert_lock'].acquire()
  # Adds the message to the list.
  mycontext['local_message_list'].append(message)
  # Sort the list first on seqNr and then IP-address.
  sort_messages()

  mycontext['index'] = mycontext['empty_html']
  for message in mycontext['local_message_list']:
    mycontext['index'] = mycontext['index'][:mycontext['index'].find('<p>')+3] + '<p>' + \
          message.content + '</p>' + mycontext['index'][mycontext['index'].find('<p>')+3:]
  mycontext['insert_lock'].release()

# Sends a message to all vessels (except this)
def send_to_vessels(message):
  for vessel in mycontext['vessels']:
      if (vessel != getmyip()):
        send_message(vessel, mycontext['port'], message)
        
# Sends a message to all ports (except this)
def send_to_local_ports(message):
  for portnr in mycontext['localports']:
    if(int(portnr) != mycontext['port']):
      send_message('127.0.0.1', int(portnr), message)

# Sends a message to specific ip:port
def send_message(ip, port, message):
  try:
    socket = openconn(ip, port)
    socket.send(message)
    socket.close()
  except Exception, e:
    print '-------SOCKET ERROR------\n' + str(e)

def message_from_string(string):
  content = string[string.find("MESSAGE:") + 8 : string.find("Seq:")]
  seqNr = int(string[string.find("Seq:") + 4 : string.find("Sender:")])
  sender = string[string.find("Sender:") + 7:]
  return Message(content, seqNr, sender)

def insert_time():
  time = mycontext['end_time'] - mycontext['start_time']
  index = mycontext['index']
  mycontext['index'] = index[:index.find('timer_div')+9] + '<h3>Time: ' + str(time) \
           +'</h3>'+ index[index.find('timer_div')+9:]